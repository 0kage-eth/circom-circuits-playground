##0xPARC notes


## Lesson 1 - Intro to ZK
 - ZK Proofs have 3 properties - soundness, completeness and zero knowledge
 - *zero knowledge* - prover response does not reveal anything of underlying info
 - *completeness* - if prover knows underlying info, they will always be able to prove correctly
 - *soundness* - if prover doesn't know the underlying info, they will *eventually* get caught
- example homomorphic encryption - I have `x` and `y` but don't have the compute to do `f(x,y)` -> I can use a private key to encrypt `x` and `y` and send to B, `enc(x)` and `enc(y)`. B can do `f(enc(x),enc(y))` and send it back to me, I can use my key to decrypt and get back `f(x,y)` -> key assumption here is that `enc(f(x,y)) = f(enc(x), enc(y))` -> claim here is homomorphic encryption is like providing a ZK proof for arbitary function

![homomprphic](./imgs/homomorhpic.png)

- In essence, homomorphic encryption gives us an important application of where ZK could be used in real life - proving identity etc would essentially be falling into this class of problems.

- `zkSNARKS`  - zk -> zero knowledge; S -> Succinct; N -> Non Interactive; ARK - Argument of Knowledge.

- High level understanding of how to work with zkSNARKs
    - Convert your problem (eg. 3 colored graph) into a function whose inputs we want to hide
    - Execute the function inside homomorphic encryption
    - Roll up the function into a short signature of execution
    - Verify the message on chain (which will be easy to do)

A quick primer on zkSNARKs [here](./zkSNARKs.md). 


## Lesson 2 - Circom Workshop
- Example explaining what Circom tries to prove
    `f(x) = (x1 + x2)*x3 - x4`
A zkSNARK is basically a signature that proves that the prover has a tuple `(x1, x2, x3, x4)` such that the result of the computation is a public output `OUT`. A zkSNARK does not tell what individual inputs are but provides a proof that the person who submitted the signature know what they are

- SNARKS have a key primitive - called `constraints`. Every SNARK has some constraints, and constraints are provided in quadratic polynomial (either addition or multiplication)

- Here is a sample circuit

![sample circuit](./imgs/CircuitSample.png)

- In the above example, prover has values x1, x2, x3, x4, y1, y2 and generates a signature that only verifies if some set constraints are true

- tech stack
    - [Circom 2.0](https://github.com/iden3/circom) 
    - [SnarkJS](https://github.com/iden3/snarkjs) 

- Circom is a programming language that allows us to write zk Circuits
- SnarkJS is a javascript library that works with the outputs of Circom

- SnarkJS can do things like
    -  generate solidity verifier
    - generate proofs on web browser
    - verify proof generated by circom etc

- How does ZKDapp work?
    - a zkSNARK node is compiled in Circom
    - Circom generates a proving and verification key
    - Proving key is sent to the webapp bundle to generate proofs on specific inputs
    - Verifying key is used on the verifier smart contract to verify this proof

- Discuss the simple [polynomial circuit](../circuits/simple-polynomial.circom) in circom starter kit   
    - note that, `x_squared` and `x_cube` are intermediate outputs that depend on value of `x`
    - they are used to define quadratic constraints 

    ```
          x_squared === x * x;
          x_cubed === x_squared * x;
          out === x_cubed - x + 7;
    ```
    - `===` represents a constraint and `<--` represents assigning a value to a signal. For more on this, refer the [circom notes](./circom.md)

    - 